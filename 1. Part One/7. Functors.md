## 요약
- 함자(Functor)는 카테고리 간의 매핑
- 객체와 모폼을 매핑하며, 카테고리의 구조를 보존
- 합성과 항등성을 보존
    - 항등성 보존: fmap id = id
    - 합성 보존: fmap (g . f) = fmap g . fmap f
- 프로그래밍에서는 주로 타입 생성자와 fmap 함수의 쌍으로 구현
- fmap: 함자의 핵심 연산으로, 원본 타입의 함수를 함자 적용 타입의 함수로 들어올림
- 

## Functors in Programming
- 프로그래밍에서 함자는 주로 endofunctor로 나타납니다(타입 카테고리에서 자신으로의 매핑).
- 예) Maybe 타입 생성자

### Equational Reasoning
- Haskell에서 함수 법칙을 증명하는 기법
- 함수 정의를 등식으로 취급하여 대체 가능

### Optional
- C++에서의 Maybe 구현 예시
    - std::optional 템플릿 사용

### Typeclasses
- Haskell의 타입클래스 메커니즘으로 함자 추상화
    - Haskell의 다형성 메커니즘으로, 공통 인터페이스를 정의합니다. Functor는 타입클래스로 구현
- Functor 타입클래스 정의

### Functor in C++
- C++에서 함자 패턴 구현의 어려움
- 템플릿과 함수 오버로딩 사용

### The List Functor
- 리스트를 함자로 구현하는 예시
    - fmap 구현 설명

### The Reader Functor
- 함수 타입을 함자로 취급
- (->) r 타입 생성자의 Functor 인스턴스 구현

## Functors as Containers
- 함자를 값의 컨테이너로 해석
    - 함자를 값을 포함하거나 생성할 수 있는 컨테이너로 해석하는 관점
- 실제 값을 포함하지 않더라도 개념적으로 컨테이너로 볼 수 있음

## Functor Composition
- 함자의 합성
- 합성된 함자의 fmap 구현
